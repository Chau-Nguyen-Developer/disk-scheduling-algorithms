//Programmer: Chau Nguyen

#include <iostream>
#include <random>

const int NUMBER_OF_CYLINDERS = 5000;
const int NUMBER_OF_REQUESTS = 1000;

int main()
{
    //Create a random generator. This is pseudo random, not completely random, by the way.
    //Use current time as seed
    // srand(time(NULL));
    std::default_random_engine generator;
    std::uniform_int_distribution<int> distribution(0, NUMBER_OF_CYLINDERS - 1);
    
    //An array to contain the cylinder request
    int cylinderRequests[NUMBER_OF_REQUESTS];

    //Generate a random series of 1,000 cylinder requests
    for (int i = 0; i < NUMBER_OF_REQUESTS; ++i)
    {
        cylinderRequests[i] = distribution(generator);
    } 
    
    //test
    std::cout << cylinderRequests[999] << " " << cylinderRequests[0] << std::endl;

    return 0;

}

//DRAFT SSTF - DRAFT 2
int SSTF(int head, std::vector<int>& myVector)
{
    if (myVector.empty())
    {
        std::cout << "Vector is empty." << std::endl;
        return 0;
    }
    std::cout << "Head is " << head << std::endl;

    int headMovement = 0;
    int min;
    int indexNextMove = 0;
    int len = myVector.size(); //this value will change according to time
    int temp;

    for(size_t i = 0; i < NUMBER_OF_REQUESTS; ++i)
    {
         min = std::abs(head - myVector[0]);

        //Identify where the head will move next to
        for(size_t i = 1; i < len; ++i)
        {
            temp = std::abs(head - myVector[i]);
            if(temp < min)
            {
                min = temp;
                indexNextMove = i;
            }
        }
        std::cout << "Current head: " << head << std::endl;
        std::cout << "Next position: " << myVector[indexNextMove] << std::endl;
        
        //Calculation head movement 
        headMovement += min;

        //Reset head
        head = myVector[indexNextMove];

        //remove the element
        std::swap(myVector[indexNextMove], myVector.back());
        myVector.pop_back();
    }

    return headMovement;

}

DRAFT SSTF - DRAFT 1
// int SSTF(int head, std::vector<int> vector)
// {
//     int result = 0;
//     //Find the next location that is closet to head
//     size_t i = 0;

//     while(i < NUMBER_OF_REQUESTS)
//     {
//         int current = vector[0];
//         int oldMinDistance = std::abs(current - head);
//         int newMinDistance = 0;
//         size_t nextIndex = 0;
//         bool justDeleted = false;
//         for (size_t j = 0; j< NUMBER_OF_REQUESTS; ++j)
//         {
//             newMinDistance = std::min(oldMinDistance, std::abs(vector[j] - head));
//             if(newMinDistance != oldMinDistance)
//             {
//                 //Obtain the next location
//                 nextIndex = j;
//             }
//         }
//         result += newMinDistance;
//         //Obtain new head value
//         head = vector[nextIndex];
//         //Delete that entry, so that we don't duplicate calculating it. 
//         vector.erase(vector.begin() + nextIndex);

        
//         //Remove the element at that index

//         //may not increment i. may done = true when delete all elements in vector. 

//         ++i;
//     } 

//     return 0;
//}